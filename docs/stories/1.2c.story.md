# User Story 1.2c: Implement Daily-React Voice Streaming for Numeroly

**Story ID:** 1.2c
**Epic:** Voice-First Mobile Application
**Status:** Ready for Development (Backend Concurrency Architecture Added)
**Created:** January 2025
**Prepared by:** Bob (Scrum Master)
**Last Updated:** January 2025 (Async Architecture & Testing Criteria Added)

---

## 📋 Story Overview

Replace custom WebSocket voice streaming implementation with **Daily.co** (via `daily-react` library) to provide managed, enterprise-grade real-time voice communication with automatic recording, sub-500ms latency, and 86% code reduction.

**Business Value:**
- Eliminates manual audio pipeline maintenance (40+ engineering hours/month saved)
- Built-in recording eliminates separate infrastructure
- Enterprise 99.99% SLA guarantees uptime
- 40-50% cost savings vs. custom infrastructure

---

## 👤 User Story Format

**As a** developer implementing Numeroly's voice streaming feature

**I want** to use Daily.co's managed SFU infrastructure for real-time voice conversations

**So that** users can have reliable, low-latency voice conversations with the AI numerology bot without custom WebSocket complexity

---

## ✅ Acceptance Criteria

### Backend Integration
- [ ] Daily.co API key configured in `.env` file (`DAILY_API_KEY`)
- [ ] Daily client Python package installed (`pip install daily-client>=1.0.0`)
- [ ] POST `/conversations` endpoint creates Daily.co room with proper configuration:
  - [ ] `max_participants: 2` (user + bot)
  - [ ] `record_on_start: true` for auto-recording
  - [ ] `lang: "vi"` for Vietnamese UI
  - [ ] Returns `room_url` and meeting `token` with 1-hour expiry
- [ ] POST `/conversations/{id}/token` endpoint generates fresh tokens for existing conversations
- [ ] PATCH `/conversations/{id}` endpoint ends conversation and captures recording URL
- [ ] Webhook handler processes Daily.co recording completion events
- [ ] Error handling for Daily.co API failures (room creation, token generation)
- [ ] Logging configured for conversation lifecycle events

### Frontend Integration
- [ ] Dependencies installed: `@daily-co/daily-react`, `@daily-co/daily-js`, `jotai`
- [ ] `DailyProviderWrapper` component wraps conversation UI with proper room setup
- [ ] `useVoiceInputService()` hook implemented with:
  - [ ] `startRecording()` - enables microphone via `useDevices()` hook
  - [ ] `stopRecording()` - disables microphone
  - [ ] `changeMicrophone(deviceId)` - switch microphone devices
  - [ ] Proper error handling for microphone access failures
  - [ ] State tracking: `isRecording`, `availableMics`, `selectedMicId`
- [ ] `useVoiceOutputService()` hook implemented with:
  - [ ] Detection of remote participant (bot/assistant)
  - [ ] Monitoring of remote audio track state (`playable`, `interrupted`, `off`)
  - [ ] `changeSpeaker(deviceId)` - switch speaker devices
  - [ ] State tracking: `remoteAudioAvailable`, `availableSpeakers`, `selectedSpeakerId`
- [ ] `ConversationView` component integrates voice services:
  - [ ] Voice button with hold-to-speak interaction pattern
  - [ ] Real-time transcription display
  - [ ] Processing status indicators (listening, processing, responding)
  - [ ] Remote audio state feedback
  - [ ] Microphone/speaker selection UI
  - [ ] End conversation button with rating prompt

### Voice Streaming Functionality
- [ ] Audio flows bidirectionally through Daily.co SFU:
  - [ ] User microphone audio → Daily SFU → Backend
  - [ ] Backend audio response → Daily SFU → User speaker
- [ ] No audio buffering or codec negotiation needed (Daily.co handles)
- [ ] Automatic echo cancellation and noise suppression active
- [ ] Network quality monitoring via `useNetwork()` hook:
  - [ ] Topology confirms `sfu` mode (not `peer`)
  - [ ] Bandwidth stats tracked for debugging
- [ ] Graceful handling of network interruptions:
  - [ ] Automatic reconnection attempts
  - [ ] Error display to user
  - [ ] Conversation state preserved in Redis

### Recording & Data
- [ ] Conversation recordings automatically captured by Daily.co
- [ ] Recording URL captured on conversation end
- [ ] Recording metadata (duration, timestamp) stored in database
- [ ] Recording accessible via conversation history endpoint
- [ ] Proper cleanup of Daily.co rooms after conversation ends

### Testing Requirements
- [ ] Manual testing on iOS and Android devices (not just emulator)
- [ ] Microphone permission flow works correctly (native prompt displayed)
- [ ] Audio streaming works under various network conditions:
  - [ ] WiFi (optimal)
  - [ ] LTE/4G
  - [ ] Poor connection (test latency tolerance)
- [ ] Recording capture verified in Daily.co dashboard
- [ ] Error scenarios tested:
  - [ ] Network disconnection during conversation
  - [ ] Microphone access denied
  - [ ] Daily.co API unavailable
  - [ ] Room creation failure

### Code Quality
- [ ] All new code follows project TypeScript/Python conventions
- [ ] Proper error handling with meaningful error messages
- [ ] Console logging for debugging (no console errors in production build)
- [ ] JSDoc/docstring comments on all exported functions
- [ ] No hardcoded URLs or API keys (all in `.env`)
- [ ] Types properly defined (TypeScript interfaces, Python type hints)

---

## 📐 Technical Implementation Details

### Backend Architecture

**Service File:** `apps/api/src/services/conversation_service.py`

**Key Methods to Implement:**
```python
async def create_conversation_with_daily(user_id: str) -> dict
async def get_daily_token(conversation_id: str, user_id: str) -> dict
async def save_user_message(conversation_id: str, text: str, confidence: float) -> dict
async def save_assistant_message(conversation_id: str, text: str, emotional_tone: str) -> dict
async def end_conversation(conversation_id: str, user_id: str, rating: Optional[int]) -> dict
async def get_conversation_history(conversation_id: str, user_id: str) -> dict
async def list_conversations(user_id: str, limit: int, offset: int) -> dict
```

**Dependencies:**
- `daily_client>=1.0.0` (Daily.co Python SDK)
- `redis.asyncio` (for conversation context)
- Existing: `fastapi`, `sqlalchemy`, `httpx`

### Frontend Architecture

**Service Hooks:** `apps/mobile/src/services/`

**Voice Input Service:** `voiceInputService.ts`
- Hook: `useVoiceInputService(options)`
- Returns: microphone control methods and state
- Uses: `useDevices()`, `useDailyEvent()` from daily-react

**Voice Output Service:** `voiceOutputService.ts`
- Hook: `useVoiceOutputService(options)`
- Returns: speaker control methods and remote audio state
- Uses: `useParticipants()`, `useDevices()`, `useDailyEvent()` from daily-react

**Conversation Component:** `apps/mobile/src/components/conversation/ConversationView.tsx`
- Integrates both voice services
- Handles app messages from Daily.co
- Manages UI state for voice interaction

### Application Message Protocol

Messages sent via Daily.co's `useAppMessage()` hook:

```typescript
// User started speaking
{ type: 'user_input_started', data: { conversationId: string } }

// User stopped speaking (trigger backend processing)
{ type: 'user_input_ended', data: { conversationId: string } }

// Backend sends transcription updates
{ type: 'transcription_update', data: { text: string, confidence: number, isFinal: boolean } }

// Backend sends processing status
{ type: 'processing_status', data: { status: 'transcribing' | 'thinking' | 'synthesizing' | 'complete' } }

// Backend sends assistant response
{ type: 'assistant_response', data: { text: string, emotionalTone: 'warm' | 'neutral' | 'energetic' } }
```

---

## 🔧 Setup & Configuration

### Prerequisites
- Node.js 16+
- Python 3.11+
- Daily.co account (free tier for development)
- Azure PostgreSQL and Redis instances (already in architecture)

### Environment Variables
```bash
# Backend (.env in apps/api)
DAILY_API_KEY=your_api_key_from_daily_dashboard
```

### Dependencies to Add

**Backend:**
```bash
cd apps/api
pip install daily-client>=1.0.0
```

**Frontend:**
```bash
cd apps/mobile
npm install @daily-co/daily-react @daily-co/daily-js jotai
```

### Files to Create
```
apps/api/src/services/conversation_service.py (300 LOC)
apps/mobile/src/services/voiceInputService.ts (150 LOC)
apps/mobile/src/services/voiceOutputService.ts (150 LOC)
apps/mobile/src/providers/DailyProvider.tsx (50 LOC)
```

### Files to Modify
```
apps/api/src/routes/conversations.py (add Daily endpoints)
apps/mobile/src/components/conversation/ConversationView.tsx (integrate services)
architecture.md (already updated with Daily.co design)
```

---

## 📚 Reference Documentation

**Complete guides available in `/docs/`:**
- `DAILY_CO_QUICKSTART.md` - 15-minute setup (copy-paste ready)
- `DAILY_CO_INTEGRATION.md` - Comprehensive reference (1-2 hours)
- `VOICE_SERVICE_EXAMPLES.md` - Production code examples (750+ LOC)
- `DAILY_CO_REFERENCE_CARD.md` - One-page developer cheat sheet
- `architecture.md` (lines 852-1481) - Updated architecture

**Key Links:**
- Daily.co Docs: https://docs.daily.co/
- daily-react GitHub: https://github.com/daily-co/daily-react
- Daily Dashboard: https://dashboard.daily.co/

---

## 🎯 Definition of Done

Story is complete when:

- [ ] Backend endpoints implemented and tested with curl
- [ ] Frontend voice services created and integrated
- [ ] ConversationView component updated with Daily.co
- [ ] Audio streaming works bidirectionally on real devices
- [ ] Recording captures verified in Daily.co dashboard
- [ ] All acceptance criteria met
- [ ] Code review passed
- [ ] No console errors or warnings
- [ ] Tested on iOS and Android devices
- [ ] Documentation updated if needed
- [ ] Story moved to "Done" in Jira/project tracker

---

## 🚨 Technical Considerations

### Network Handling
- Daily.co automatically handles reconnection
- Use `useNetwork()` hook to monitor topology (should be `sfu`)
- Implement retry logic for backend API calls (not Daily calls)

### Microphone Permissions
- iOS: Requires `NSMicrophoneUsageDescription` in Info.plist
- Android: Requires `RECORD_AUDIO` permission in AndroidManifest.xml
- React Native will prompt user automatically

### Audio Codec Compatibility
- Daily.co handles codec negotiation automatically
- No manual codec conversion needed (unlike custom WebSocket)
- Supports: Opus (preferred), PCMU, PCMA, G729, iLBC, Speex, etc.

### Recording Storage
- Default: Daily.co stores recordings
- Option: Configure to store in Azure Blob Storage
- Retention: Default 30 days (configurable)

### Cost Impact
- Voice streaming: ~$0.50/hour per conversation
- Recording: +$0.10/hour
- Estimate for 1000 convos/day @ 0.5 hrs each: ~$9,000/month
- 40-50% cheaper than custom infrastructure

---

## 🔄 Backend Concurrency & Non-Blocking Architecture

**Critical for voice streaming performance:** All backend operations must be non-blocking to prevent the FastAPI event loop from freezing during concurrent voice streams.

### Async Implementation Requirements

#### 1. Daily.co Client Integration (Blocking Risk ⚠️)

**Requirement:** All `daily_client` calls must be non-blocking.

**Action needed:** Before implementation, verify async support in `daily_client>=1.0.0`:

```python
# VERIFY: Is daily_client async-capable?
# Check: daily_client.create_room() - sync or async?
# Check: daily_client.create_meeting_token() - sync or async?
# Check: daily_client.get_room() - sync or async?
```

**If daily_client is sync-only, use asyncio.to_thread():**

```python
# DO THIS: Wrap sync calls in thread pool
room = await asyncio.to_thread(
    self.daily_client.create_room,
    config=room_config
)

token = await asyncio.to_thread(
    self.daily_client.create_meeting_token,
    room_url=room['url'],
    expires_in_seconds=3600
)
```

**If daily_client is async-capable (preferred):**

```python
# PREFERRED: Use native async methods
room = await self.daily_client.create_room_async(config=room_config)
token = await self.daily_client.create_meeting_token_async(...)
```

#### 2. Message Processing Concurrency (Race Condition Risk ⚠️)

**Requirement:** Concurrent message saves from multiple voice streams must not create race conditions on conversation state.

**Pattern 1 - Distributed Lock (Redis WATCH):**

```python
async def save_user_message(self, conversation_id: str, text: str, confidence: float):
    """
    Save message with optimistic locking to prevent concurrent save races.
    """
    while True:
        # Watch conversation key for changes
        await self.redis.watch(f"conv:{conversation_id}")

        # Check current state
        current_count = await self.redis.get(f"conv:{conversation_id}:msg_count")

        # Start transaction
        pipe = self.redis.pipeline(transaction=True)
        await pipe.multi()

        try:
            # Save to database (async)
            message = await self.db.execute(
                insert(MessageTable).values(
                    conversation_id=conversation_id,
                    user_text=text,
                    confidence=confidence
                )
            )

            # Update cache
            await pipe.incr(f"conv:{conversation_id}:msg_count")
            await pipe.execute()
            return message

        except redis.WatchError:
            # Retry if watched key changed
            continue
```

**Pattern 2 - Semaphore Limiting:**

```python
class ConversationService:
    def __init__(self):
        # Limit concurrent saves per conversation to prevent queue buildup
        self.message_semaphores = {}  # Dict[conversation_id, asyncio.Semaphore]

    async def save_user_message(self, conversation_id: str, text: str, confidence: float):
        # Get or create semaphore for this conversation
        if conversation_id not in self.message_semaphores:
            self.message_semaphores[conversation_id] = asyncio.Semaphore(1)

        async with self.message_semaphores[conversation_id]:
            # Exclusive access to conversation state
            await self.db.execute(
                insert(MessageTable).values(
                    conversation_id=conversation_id,
                    user_text=text,
                    confidence=confidence
                )
            )
```

#### 3. Transaction Safety (Partial Failure Risk ⚠️)

**Requirement:** Room creation + token generation must be atomic. If token generation fails, room must be deleted.

```python
async def create_conversation_with_daily(self, user_id: str) -> dict:
    """
    Create Daily.co room with automatic rollback on failure.
    """
    room = None
    try:
        # Step 1: Create room (may block if sync)
        room = await asyncio.to_thread(
            self.daily_client.create_room,
            config={"properties": {"max_participants": 2, "record_on_start": True}}
        )

        # Step 2: Create token (may fail)
        token = await asyncio.to_thread(
            self.daily_client.create_meeting_token,
            room_url=room['url'],
            expires_in_seconds=3600
        )

        # Step 3: Save to database (may fail)
        db_record = await self.db.execute(
            insert(ConversationTable).values(
                user_id=user_id,
                room_url=room['url'],
                token=token,
                created_at=datetime.utcnow()
            )
        )

        return {
            "conversation_id": db_record.id,
            "room_url": room['url'],
            "token": token
        }

    except Exception as e:
        # Rollback: Delete room if created but token/DB failed
        if room:
            await asyncio.to_thread(
                self.daily_client.delete_room,
                room_url=room['url']
            )
        raise ConversationCreationError(f"Failed to create conversation: {str(e)}")
```

#### 4. Database Operations (Must use async SQLAlchemy)

```python
# GOOD: Async all the way
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

async def get_conversation(self, conversation_id: str, session: AsyncSession):
    result = await session.execute(
        select(ConversationTable).where(
            ConversationTable.id == conversation_id
        )
    )
    return result.scalars().first()

# BAD: Don't do this (blocks event loop)
session = Session()
conversation = session.query(ConversationTable).get(conversation_id)
```

#### 5. Redis Operations (Must use redis.asyncio)

```python
# GOOD: Async Redis
import redis.asyncio

async def get_conversation_context(self, conversation_id: str):
    redis_client = redis.asyncio.from_url("redis://...")
    context = await redis_client.get(f"conv:{conversation_id}:context")
    return json.loads(context)

# BAD: Don't do this (blocks event loop)
import redis
redis_client = redis.StrictRedis(...)
context = redis_client.get(f"conv:{conversation_id}:context")
```

### Acceptance Criteria Additions

Add these criteria to the "Backend Integration" section:

- [ ] **Async-Safe daily_client Integration**
  - [ ] All `daily_client` calls are non-blocking (verified via code review)
  - [ ] If `daily_client` is sync-only, all calls wrapped with `asyncio.to_thread()`
  - [ ] No blocking calls in async functions
  - [ ] Load testing confirms no event loop freezing under 10 concurrent conversations

- [ ] **Concurrent Message Processing Safety**
  - [ ] Multiple simultaneous messages don't create database race conditions
  - [ ] Redis WATCH or Semaphore pattern implemented for conversation state
  - [ ] Unit test `test_concurrent_message_saves()` passes

- [ ] **Transaction Safety for Room Creation**
  - [ ] Room + token creation is transactional
  - [ ] Failed token generation triggers automatic room cleanup
  - [ ] Database record only created after successful room + token
  - [ ] Unit test `test_room_creation_rollback_on_token_failure()` passes

### Backend Unit Tests (Addition to Testing Requirements)

Add these test criteria:

- [ ] `test_create_conversation_with_daily()` - Verify room + token creation succeeds
- [ ] `test_create_conversation_with_daily_token_failure()` - Verify room deleted if token fails
- [ ] `test_concurrent_message_saves()` - Verify no race conditions with 5 simultaneous saves
- [ ] `test_daily_api_unavailable()` - Verify graceful error handling when Daily.co API fails
- [ ] `test_conversation_cleanup_on_end()` - Verify room properly deleted and resources freed
- [ ] `test_async_non_blocking_under_load()` - Load test with 10 concurrent conversations confirms no event loop blocking

### References

See `docs/DAILY_CO_ASYNC_PATTERNS.md` for:
- Detailed async/await patterns for Python FastAPI
- daily_client async wrapping examples
- Redis transaction patterns
- Database concurrency best practices
- Load testing guidelines

---

## ⚠️ Known Limitations

1. **No video support** - Intentionally disabled for cost savings (voice-only app)
2. **SFU topology only** - Direct peer-to-peer unavailable (not needed for 1-on-1 + bot)
3. **App messages latency** - App messages have ~100-200ms latency (acceptable for status updates)

---

## 🔄 Related Stories

- **1.2a:** User authentication with Azure AD B2C (prerequisite)
- **1.2b:** Backend conversation service infrastructure (prerequisite)
- **1.3a:** Transcription service integration with Azure Speech Services
- **1.3b:** TTS service integration with ElevenLabs
- **1.4a:** UI conversation component with numerology display

---

## 📝 Notes for Developer

**Important:**
- DO NOT implement custom WebSocket audio streaming (that's what Daily.co replaces)
- Use provided code examples from `VOICE_SERVICE_EXAMPLES.md` as templates
- Test on real devices, not just emulator (audio APIs differ)
- Microphone access may fail silently if permissions not granted
- Daily.co free tier is limited; use sandbox for testing

**Debugging:**
- Enable Daily.co debug logging: `window.DailyDebug = true`
- Check Daily.co dashboard for room status
- Monitor network stats with `useNetwork()` hook
- Use console logging sparingly (remove before production)

---

## 📊 Story Metrics

| Metric | Value |
|--------|-------|
| Complexity | Medium (4-5 story points) |
| Priority | High (core feature) |
| Time Estimate | 5-7 days (backend 2d, frontend 3d, testing 1-2d) |
| Dependencies | Story 1.2a, 1.2b complete |
| Blockers | None |
| Code Lines | ~750 LOC production code |
| Documentation | 6 guides already provided |

---

## 🏁 Story Ready for Handoff

This story is **complete and ready for implementation**. All code examples, documentation, and architecture details are prepared. Developer can start immediately using provided templates and examples.

**Prepared by:** Bob (Scrum Master)
**Date:** January 2025
**Status:** ✅ Ready for Sprint
